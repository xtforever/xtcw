\input wbuildmac.tex
\Class{Wim2}Widget zur Anzeige verschiedener Images



\Publicvars
\Table{Wim2}
XtNpicName&XtCPicName&String &NULL \cr
XtNxoff&XtCXOff&int &100 \cr
XtNyoff&XtCYoff&int &100 \cr
XtNzoom&XtCZoom&int &100 \cr
XtNcallback&XtCCallback&Callback&NULL \cr
XtNuser{\underline}data&XtCUser{\underline}data&int &0 \cr
\endTable
\Section
\Publicvar{XtNpicName}
String  picName = {\langle}String{\rangle}NULL 

\Section
\Publicvar{XtNxoff}
int  xoff = 100 

\Section
\Publicvar{XtNyoff}
int  yoff = 100 

\Section
\Publicvar{XtNzoom}
int  zoom = 100 

\Section
\Publicvar{XtNcallback}
{\langle}Callback{\rangle} XtCallbackList  callback = NULL 

\Section
\Publicvar{XtNuser{\underline}data}
int  user{\underline}data = 0 

\End\Table{Core}
XtNx&XtCX&Position &0 \cr
XtNy&XtCY&Position &0 \cr
XtNwidth&XtCWidth&Dimension &0 \cr
XtNheight&XtCHeight&Dimension &0 \cr
borderWidth&XtCBorderWidth&Dimension &0 \cr
XtNcolormap&XtCColormap&Colormap &NULL \cr
XtNdepth&XtCDepth&Int &0 \cr
destroyCallback&XtCDestroyCallback&XTCallbackList &NULL \cr
XtNsensitive&XtCSensitive&Boolean &True \cr
XtNtm&XtCTm&XTTMRec &NULL \cr
ancestorSensitive&XtCAncestorSensitive&Boolean &False \cr
accelerators&XtCAccelerators&XTTranslations &NULL \cr
borderColor&XtCBorderColor&Pixel &0 \cr
borderPixmap&XtCBorderPixmap&Pixmap &NULL \cr
background&XtCBackground&Pixel &0 \cr
backgroundPixmap&XtCBackgroundPixmap&Pixmap &NULL \cr
mappedWhenManaged&XtCMappedWhenManaged&Boolean &True \cr
XtNscreen&XtCScreen&Screen *&NULL \cr
\endTable
\Translations
\Section
\Code
{\langle}Btn1Motion{\rangle}: motion{\underline}start() \endCode


\Section
\Code
{\langle}Btn3Motion{\rangle}: b5{\underline}start() \endCode


\Section
\Code
{\langle}BtnUp{\rangle}: motion{\underline}end() \endCode


\End\Actions
\Section
\Action{motion{\underline}end}\Code
void motion{\underline}end({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
        {\dollar}drag{\underline}time=0;
        XtCallCallbackList( {\dollar}, {\dollar}callback, event );
{\rbrace}\endCode


\Section
\Action{b5{\underline}start}\Code
void b5{\underline}start({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}
        TRACE(2,"");
        int y = event-{\rangle}xbutton.y;
        int x = event-{\rangle}xbutton.x;
        ulong t = (ulong ) event-{\rangle}xbutton.time;

        if( {\dollar}drag{\underline}time == 0
        {\bar}{\bar} {\dollar}drag{\underline}time +1000 {\langle} t ) goto restart{\underline}drag;

        int mvx = {\dollar}dx - x;
        int mvy = {\dollar}dy - y;
        TRACE(2,"{\percent}d {\percent}d", mvx, mvy );
        if( mvx == 0 {\ampersand}{\ampersand} mvy== 0 ) return;

        mvx += mvy;
        {\dollar}zoom += mvx;
        if( {\dollar}zoom {\langle} 1 ) {\dollar}zoom = 1;
        else if( {\dollar}zoom {\rangle} 400 ) {\dollar}zoom = 400;

        {\dollar}expose( {\dollar}, NULL, NULL );
                
        restart{\underline}drag:
        {\dollar}dx = x;
        {\dollar}dy = y;
        {\dollar}drag{\underline}time = t;

{\rbrace}\endCode


\Section
\Action{motion{\underline}start}\Code
void motion{\underline}start({\dollar}, XEvent* event, String* params, Cardinal* num{\underline}params)
{\lbrace}

        int y = event-{\rangle}xbutton.y;
        int x = event-{\rangle}xbutton.x;
        ulong t = (ulong ) event-{\rangle}xbutton.time;

        if( {\dollar}drag{\underline}time == 0
        {\bar}{\bar} {\dollar}drag{\underline}time +1000 {\langle} t ) goto restart{\underline}drag;

        int mvx = {\dollar}dx - x;
        int mvy = {\dollar}dy - y;
        TRACE(2,"{\percent}d {\percent}d", mvx, mvy );
        if( mvx == 0 {\ampersand}{\ampersand} mvy== 0 ) return;
        {\dollar}xoff += mvx;
        {\dollar}yoff += mvy;
        {\dollar}expose( {\dollar}, NULL, NULL );
                
        restart{\underline}drag:
        {\dollar}dx = x;
        {\dollar}dy = y;
        {\dollar}drag{\underline}time = t;
{\rbrace}\endCode


\End\Imports
\Section
\Code
{\incl} {\langle}X11/Xregion.h{\rangle}\endCode


\Section
\Code
{\incl} {\langle}Imlib2.h{\rangle}\endCode


\Section
\Code
{\incl} {\langle}X11/Xft/Xft.h{\rangle}\endCode


\Section
\Code
{\incl} "converters-xft.h"\endCode


\Section
\Code
{\incl} "xutil.h"\endCode


\Section
\Code
{\incl} "mls.h"\endCode


\End\Privatevars
\Section
\Code
float  scale\endCode


\Section
\Code
Imlib{\underline}Updates  upd\endCode


\Section
\Code
ulong  drag{\underline}time\endCode


\Section
\Code
int  dx\endCode


\Section
\Code
int  dy\endCode


\Section
\Code
Display * dpy\endCode


\Section
\Code
GC  bg{\underline}fill{\underline}gc\endCode


\End\Classvars
\Section
\Code
compress{\underline}exposure = True \endCode


\Section
\Code
compress{\underline}motion = True \endCode


\End\Methods
\Section
\Code
class{\underline}initialize()
{\lbrace}
  m{\underline}init(); 
{\rbrace}\endCode


\Section
\Code
initialize(Widget  request, {\dollar}, ArgList  args, Cardinal * num{\underline}args)
{\lbrace} 
  XGCValues     values;
  {\dollar}dpy = XtDisplay({\dollar});
  if( {\dollar}width == 0 )  {\dollar}width   = 100;
  if( {\dollar}height == 0 ) {\dollar}height =  100;
  values.foreground = {\dollar}background{\underline}pixel; 
  {\dollar}bg{\underline}fill{\underline}gc = XtGetGC({\dollar}, GCForeground, {\ampersand}values);    
{\rbrace}\endCode


\Section
\Code
destroy({\dollar})
{\lbrace}
    XtReleaseGC({\dollar},{\dollar}bg{\underline}fill{\underline}gc);
{\rbrace}\endCode


\Section
\Code
expose({\dollar}, XEvent * event, Region  region)
{\lbrace} 
    if( !XtIsRealized({\dollar})) return;
    redisplay( {\dollar}, region );
{\rbrace}\endCode


\Section
\Code
Boolean  set{\underline}values(Widget  old, Widget  request, {\dollar}, ArgList  args, Cardinal * num{\underline}args)
{\lbrace}

  /* user changes current pixmap */
  if( ({\dollar}old{\dollar}xoff != {\dollar}xoff ) {\bar}{\bar}
      ({\dollar}old{\dollar}yoff != {\dollar}yoff ) {\bar}{\bar}  
      ({\dollar}old{\dollar}zoom != {\dollar}zoom ) {\bar}{\bar}
      ({\dollar}old{\dollar}picName != {\dollar}picName))   {\lbrace}   redisplay({\dollar},NULL); return True; {\rbrace} 

  return False;
{\rbrace}\endCode


\End\Utilities
\Section
merge update rects


\Code
Imlib{\underline}Updates  get{\underline}imlib{\underline}update({\dollar}, Region  reg)
{\lbrace}
    int i;
    Imlib{\underline}Updates up = NULL;

    if( reg ) {\lbrace}
        Box *b = reg-{\rangle}rects;
        for(i=0;i{\langle}reg-{\rangle}numRects;i++, b++) {\lbrace}
            up = imlib{\underline}update{\underline}append{\underline}rect(up, b-{\rangle}x1,b-{\rangle}y1,
                                              b-{\rangle}x2 - b-{\rangle}x1 +1,
                                              b-{\rangle}y2 - b-{\rangle}y1 +1 );
        {\rbrace}
    {\rbrace} else {\lbrace}
        up = imlib{\underline}update{\underline}append{\underline}rect(up, 0,0, {\dollar}width, {\dollar}height );
    {\rbrace}

    /* merge and clip rectangles */
    up = imlib{\underline}updates{\underline}merge{\underline}for{\underline}rendering(up, {\dollar}width, {\dollar}height );
    return up;
{\rbrace}\endCode


\Section
das rectangle r im window aktualisieren
  xoff,yoff und scale wird verwendet 
  die quelle wird vor dem update scaliert 


\Code
put{\underline}image({\dollar}, Imlib{\underline}Image  image, XRectangle * r)
{\lbrace}
    Imlib{\underline}Image src;
    int src{\underline}x, src{\underline}y, src{\underline}w, src{\underline}h;

    src = imlib{\underline}create{\underline}image(r-{\rangle}width,r-{\rangle}height);
    imlib{\underline}context{\underline}set{\underline}image(src);

    src{\underline}x = ({\dollar}xoff+r-{\rangle}x) / {\dollar}scale;
    src{\underline}y = ({\dollar}yoff+r-{\rangle}y) / {\dollar}scale;
    src{\underline}w = r-{\rangle}width / {\dollar}scale;
    src{\underline}h = r-{\rangle}height / {\dollar}scale;



    imlib{\underline}blend{\underline}image{\underline}onto{\underline}image( image,0, 
                                src{\underline}x,src{\underline}y,src{\underline}w,src{\underline}h,
                                0,0,r-{\rangle}width,r-{\rangle}height );

  imlib{\underline}render{\underline}image{\underline}on{\underline}drawable(r-{\rangle}x, r-{\rangle}y);
  imlib{\underline}free{\underline}image();

    TRACE(2,"SRC({\percent}d {\percent}d {\percent}d {\percent}d) DST({\percent}d {\percent}d {\percent}d {\percent}d)", src{\underline}x,src{\underline}y,src{\underline}w,src{\underline}h,
        r-{\rangle}x,r-{\rangle}y,r-{\rangle}width, r-{\rangle}height );
{\rbrace}\endCode


\Section
\Code
redisplay({\dollar}, Region  reg)
{\lbrace}
    Imlib{\underline}Updates up,c;
    Imlib{\underline}Image image;
    int w,h;

    image = imlib{\underline}load{\underline}image({\dollar}picName);
    if( !image ) return;
    imlib{\underline}context{\underline}set{\underline}image(image);

    up = get{\underline}imlib{\underline}update({\dollar},reg);
    if( !up ) {\lbrace} imlib{\underline}free{\underline}image(); return; {\rbrace}

    imlib{\underline}context{\underline}set{\underline}display({\dollar}dpy);
    imlib{\underline}context{\underline}set{\underline}visual(DefaultVisual({\dollar}dpy, DefaultScreen({\dollar}dpy))) ;
    imlib{\underline}context{\underline}set{\underline}colormap(DefaultColormap({\dollar}dpy,DefaultScreen({\dollar}dpy)));     
    imlib{\underline}context{\underline}set{\underline}drawable(XtWindow({\dollar}));
    imlib{\underline}set{\underline}cache{\underline}size(204800 * 1024);
    imlib{\underline}context{\underline}set{\underline}blend(1);

    w = imlib{\underline}image{\underline}get{\underline}width();
    h = imlib{\underline}image{\underline}get{\underline}height();

    /* ZOOM */
    {\dollar}scale = ({\dollar}zoom) * 1.0 / 100;
    if( {\dollar}scale {\langle}= 0 ) {\dollar}scale = 1;
    w = w * {\dollar}scale;
    h = h * {\dollar}scale;

    /* SCROLL */
    if( {\dollar}xoff+{\dollar}width {\rangle}  w ) {\dollar}xoff = w-{\dollar}width;
    if( {\dollar}yoff+{\dollar}height {\rangle}  h ) {\dollar}yoff = h-{\dollar}height;
    if( {\dollar}xoff {\langle} 0 ) {\dollar}xoff = 0;
    if( {\dollar}yoff {\langle} 0 ) {\dollar}yoff = 0;

    /* DRAW */
    int up{\underline}x, up{\underline}y, up{\underline}w, up{\underline}h;
    XRectangle r;
    for (c = up; c; c = imlib{\underline}updates{\underline}get{\underline}next(c) )
        {\lbrace}
            imlib{\underline}updates{\underline}get{\underline}coordinates(c,{\ampersand}up{\underline}x, {\ampersand}up{\underline}y, {\ampersand}up{\underline}w, {\ampersand}up{\underline}h);
            r.x = up{\underline}x; r.y = up{\underline}y; r.width = up{\underline}w; r.height = up{\underline}h;
            put{\underline}image( {\dollar}, image, {\ampersand}r );
        {\rbrace}
    imlib{\underline}context{\underline}set{\underline}image(image);
    imlib{\underline}free{\underline}image();
    imlib{\underline}updates{\underline}free(up);

    /* CLEAR BACKGROUND */
    /* check if src image is small than window */
    TRACE(2,"SRC ({\percent}d {\percent}d)", w, h );
    if( w {\langle} {\dollar}width ) {\lbrace}
        XFillRectangle( {\dollar}dpy, XtWindow({\dollar}), {\dollar}bg{\underline}fill{\underline}gc,
                    w,0, {\dollar}width-w, {\dollar}height );
    {\rbrace}
    if( h {\langle} {\dollar}height ) {\lbrace}
        XFillRectangle( {\dollar}dpy, XtWindow({\dollar}), {\dollar}bg{\underline}fill{\underline}gc,
                    0,h, {\dollar}width, {\dollar}height - h );
    
    {\rbrace}


{\rbrace}\endCode


\End\bye
